{"version":3,"sources":["../../src/js/AI.js"],"names":["AI","board","mode","console","log","findBestMoveFromList","findRandomMove","findBestMoveBadAI","findBestMinimaxMove","possibleMoves","getBlankSquares","getGameState","symbols","length","winningMoves","nonLosingMoves","losingMoves","moveLoop","move","boardWithNewMove","copyWithMove","row","cell","gameState","push","possiblePlayerResponses","playerResponse","boardWithPlayerResponse","gameStateWithPlayerMove","Utils","randomElementFromArray","bestMoves","bestMoveEval","moveIndex","minimaxEval","evalMoveMinimax","bestMove","turn","i","currentMoveEval","favouredMoves","currentMove","getSquare","blankSquares"],"mappings":"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","file":"AI.js","sourcesContent":["class AI {\n    static findBestMove(board, mode) {\n        console.log({ mode });\n        if (mode === \"easy\") {\n            return this.findBestMoveFromList(board);\n        } else if (mode === \"medium\") {\n            return this.findRandomMove(board);\n        } else if (mode === \"hard\") {\n            return this.findBestMoveBadAI(board);\n        } else {\n            return this.findBestMinimaxMove(board);\n        }\n    }\n\n    static findBestMoveBadAI(board) {\n        let possibleMoves = board.getBlankSquares();\n        if (board.getGameState() !== symbols['blank'] || possibleMoves.length == 0) {\n            return null;\n        }\n        let winningMoves = [];\n        let nonLosingMoves = [];\n        let losingMoves = [];\n        moveLoop:\n        for (const move of possibleMoves) {\n            let boardWithNewMove = board.copyWithMove(symbols['player2'], move.row, move.cell);\n            let gameState = boardWithNewMove.getGameState();\n            if (gameState === symbols['player2']) {\n                winningMoves.push(move);\n                continue;\n            }\n            let possiblePlayerResponses = boardWithNewMove.getBlankSquares();\n            for (const playerResponse of possiblePlayerResponses) {\n                let boardWithPlayerResponse = boardWithNewMove.copyWithMove(symbols['player'], playerResponse.row, playerResponse.cell);\n                let gameStateWithPlayerMove = boardWithPlayerResponse.getGameState();\n                if (gameStateWithPlayerMove === symbols['player']) {\n                    losingMoves.push(move);\n                    continue moveLoop;\n                }\n            }\n            nonLosingMoves.push(move);\n        }\n        if (winningMoves.length > 0) {\n            return Utils.randomElementFromArray(winningMoves);\n        } else if (nonLosingMoves.length > 0) {\n            return Utils.randomElementFromArray(nonLosingMoves);\n        } else if (losingMoves.length > 0) {\n            return Utils.randomElementFromArray(losingMoves);\n        }\n        // No moves\n        return null\n    }\n\n    static findBestMinimaxMove(board) {\n        let possibleMoves = board.getBlankSquares();\n        let bestMoves = [];\n        let bestMoveEval = -2;\n        for (let moveIndex = 0; moveIndex < possibleMoves.length; moveIndex++) {\n            let move = possibleMoves[moveIndex]\n            let boardWithNewMove = board.copyWithMove(symbols[\"player2\"], move.row, move.cell);\n            let minimaxEval = this.evalMoveMinimax(boardWithNewMove, -1);\n            if (minimaxEval > bestMoveEval) {\n                bestMoveEval = minimaxEval;\n                bestMoves = [move];\n            } else if (minimaxEval == bestMoveEval) {\n                bestMoves.push(move);\n            }\n        }\n        if (bestMoveEval == -2) {\n            console.log(\"Something bad happened!\");\n            return null;\n        }\n        let bestMove = Utils.randomElementFromArray(bestMoves);\n        return bestMove;\n    }\n\n    static evalMoveMinimax(board, turn) {\n        let possibleMoves = board.getBlankSquares();\n        // Check for terminal states\n        let gameState = board.getGameState();\n        if (gameState !== symbols[\"blank\"]) {\n            return gameState == symbols[\"player2\"] ? 1 : -1;\n        }\n        if (possibleMoves.length < 1) {\n            return 0;\n        }\n        let bestMoveEval = 0;\n        if (turn == -1) {\n            // MINI\n            bestMoveEval = 2;\n            for (let i = 0; i < possibleMoves.length; i++) {\n                let move = possibleMoves[i];\n                let boardWithNewMove = board.copyWithMove(symbols[\"player\"], move.row, move.cell);\n                let currentMoveEval = this.evalMoveMinimax(boardWithNewMove, -turn);\n                if (currentMoveEval < bestMoveEval) {\n                    bestMoveEval = currentMoveEval;\n                }\n            }\n        } else {\n            // MAX\n            bestMoveEval = -2;\n            for (let i = 0; i < possibleMoves.length; i++) {\n                let move = possibleMoves[i];\n                let boardWithNewMove = board.copyWithMove(symbols[\"player2\"], move.row, move.cell);\n                let currentMoveEval = this.evalMoveMinimax(boardWithNewMove, -turn);\n                if (currentMoveEval > bestMoveEval) {\n                    bestMoveEval = currentMoveEval;\n                }\n            }\n        }\n        return bestMoveEval;\n    }\n\n    static findBestMoveFromList(board) {\n        let favouredMoves = [{\n                row: 1,\n                cell: 1\n            },\n            {\n                row: 0,\n                cell: 1\n            },\n            {\n                row: 1,\n                cell: 2\n            },\n            {\n                row: 2,\n                cell: 1\n            },\n            {\n                row: 1,\n                cell: 0\n            },\n            {\n                row: 0,\n                cell: 0\n            },\n            {\n                row: 0,\n                cell: 2\n            },\n            {\n                row: 2,\n                cell: 2\n            },\n            {\n                row: 2,\n                cell: 0\n            },\n        ];\n        for (let moveIndex = 0; moveIndex < favouredMoves.length; moveIndex++) {\n            const currentMove = favouredMoves[moveIndex];\n            if (board.getSquare(currentMove.row, currentMove.cell) == symbols[\"blank\"]) {\n                return currentMove;\n            }\n        }\n        return null;\n    }\n\n    static findRandomMove(board) {\n        let blankSquares = board.getBlankSquares();\n        return Utils.randomElementFromArray(blankSquares);\n    }\n}"]}