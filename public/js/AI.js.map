{"version":3,"sources":["../../src/js/AI.js"],"names":["AI","board","mode","findBestMoveFromList","findRandomMove","findBestMoveBadAI","findBestMinimaxMove","possibleMoves","getBlankSquares","getGameState","symbols","length","winningMoves","nonLosingMoves","losingMoves","moveLoop","move","boardWithNewMove","copyWithMove","row","cell","gameState","push","possiblePlayerResponses","playerResponse","boardWithPlayerResponse","gameStateWithPlayerMove","console","log","Utils","randomElementFromArray","bestMoves","bestMoveEval","moveIndex","minimaxEval","evalMoveMinimax","bestMove","turn","i","currentMoveEval","favouredMoves","currentMove","getSquare","blankSquares"],"mappings":"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","file":"AI.js","sourcesContent":["class AI {\n    static findBestMove(board, mode) {\n        if (mode === \"easy\") {\n            return this.findBestMoveFromList(board);\n        } else if (mode === \"medium\") {\n            return this.findRandomMove(board);\n        } else if (mode === \"hard\") {\n            return this.findBestMoveBadAI(board);\n        } else {\n            return this.findBestMinimaxMove(board);\n        }\n    }\n\n    static findBestMoveBadAI(board) {\n        let possibleMoves = board.getBlankSquares();\n        if (board.getGameState() !== symbols['blank'] || possibleMoves.length == 0) {\n            return null;\n        }\n        let winningMoves = [];\n        let nonLosingMoves = [];\n        let losingMoves = [];\n        moveLoop:\n        for (const move of possibleMoves) {\n            let boardWithNewMove = board.copyWithMove(symbols['computer'], move.row, move.cell);\n            let gameState = boardWithNewMove.getGameState();\n            if (gameState === symbols['computer']) {\n                winningMoves.push(move);\n                continue;\n            }\n            let possiblePlayerResponses = boardWithNewMove.getBlankSquares();\n            for (const playerResponse of possiblePlayerResponses) {\n                let boardWithPlayerResponse = boardWithNewMove.copyWithMove(symbols['player'], playerResponse.row, playerResponse.cell);\n                let gameStateWithPlayerMove = boardWithPlayerResponse.getGameState();\n                if (gameStateWithPlayerMove === symbols['player']) {\n                    losingMoves.push(move);\n                    continue moveLoop;\n                }\n            }\n            nonLosingMoves.push(move);\n        }\n        console.log({ winningMoves, nonLosingMoves, losingMoves });\n        if (winningMoves.length > 0) {\n            return Utils.randomElementFromArray(winningMoves);\n        } else if (nonLosingMoves.length > 0) {\n            return Utils.randomElementFromArray(nonLosingMoves);\n        } else if (losingMoves.length > 0) {\n            return Utils.randomElementFromArray(losingMoves);\n        }\n        // No moves\n        return null\n    }\n\n    static findBestMinimaxMove(board) {\n        let possibleMoves = board.getBlankSquares();\n        let bestMoves = [];\n        let bestMoveEval = -2;\n        for (let moveIndex = 0; moveIndex < possibleMoves.length; moveIndex++) {\n            let move = possibleMoves[moveIndex]\n            let boardWithNewMove = board.copyWithMove(symbols[\"computer\"], move.row, move.cell);\n            let minimaxEval = this.evalMoveMinimax(boardWithNewMove, -1);\n            if (minimaxEval > bestMoveEval) {\n                bestMoveEval = minimaxEval;\n                bestMoves = [move];\n            } else if (minimaxEval == bestMoveEval) {\n                bestMoves.push(move);\n            }\n        }\n        if (bestMoveEval == -2) {\n            console.log(\"Something bad happened!\");\n            return null;\n        }\n        let bestMove = Utils.randomElementFromArray(bestMoves);\n        return bestMove;\n    }\n\n    static evalMoveMinimax(board, turn) {\n        let possibleMoves = board.getBlankSquares();\n        // Check for terminal states\n        let gameState = board.getGameState();\n        if (gameState !== symbols[\"blank\"]) {\n            return gameState == symbols[\"computer\"] ? 1 : -1;\n        }\n        if (possibleMoves.length < 1) {\n            return 0;\n        }\n        let bestMoveEval = 0;\n        if (turn == -1) {\n            // MINI\n            bestMoveEval = 2;\n            for (let i = 0; i < possibleMoves.length; i++) {\n                let move = possibleMoves[i];\n                let boardWithNewMove = board.copyWithMove(symbols[\"player\"], move.row, move.cell);\n                let currentMoveEval = this.evalMoveMinimax(boardWithNewMove, -turn);\n                if (currentMoveEval < bestMoveEval) {\n                    bestMoveEval = currentMoveEval;\n                }\n            }\n        } else {\n            // MAX\n            bestMoveEval = -2;\n            for (let i = 0; i < possibleMoves.length; i++) {\n                let move = possibleMoves[i];\n                let boardWithNewMove = board.copyWithMove(symbols[\"computer\"], move.row, move.cell);\n                let currentMoveEval = this.evalMoveMinimax(boardWithNewMove, -turn);\n                if (currentMoveEval > bestMoveEval) {\n                    bestMoveEval = currentMoveEval;\n                }\n            }\n        }\n        return bestMoveEval;\n    }\n\n    static findBestMoveFromList(board) {\n        let favouredMoves = [{\n                row: 1,\n                cell: 1\n            },\n            {\n                row: 0,\n                cell: 1\n            },\n            {\n                row: 1,\n                cell: 2\n            },\n            {\n                row: 2,\n                cell: 1\n            },\n            {\n                row: 1,\n                cell: 0\n            },\n            {\n                row: 0,\n                cell: 0\n            },\n            {\n                row: 0,\n                cell: 2\n            },\n            {\n                row: 2,\n                cell: 2\n            },\n            {\n                row: 2,\n                cell: 0\n            },\n        ];\n        for (let moveIndex = 0; moveIndex < favouredMoves.length; moveIndex++) {\n            const currentMove = favouredMoves[moveIndex];\n            if (board.getSquare(currentMove.row, currentMove.cell) == symbols[\"blank\"]) {\n                return currentMove;\n            }\n        }\n        return null;\n    }\n\n    static findRandomMove(board) {\n        let blankSquares = board.getBlankSquares();\n        return Utils.randomElementFromArray(blankSquares);\n    }\n}"]}