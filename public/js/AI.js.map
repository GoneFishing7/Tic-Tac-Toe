{"version":3,"sources":["../../src/js/AI.js"],"names":["AI","board","mode","findBestMinimaxMove","findBestMoveFromList","findRandomMove","possibleMoves","getBlankSquares","bestMoves","bestMoveEval","moveIndex","length","move","boardWithNewMove","copyWithMove","symbols","row","cell","minimaxEval","evalMoveMinimax","push","console","log","bestMove","Utils","randomElementFromArray","turn","gameState","getGameState","i","currentMoveEval","favouredMoves","currentMove","getSquare","blankSquares"],"mappings":"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","file":"AI.js","sourcesContent":["class AI {\n    static findBestMove(board, mode) {\n        if (!mode) {\n            return this.findBestMinimaxMove(board);\n        }\n        if (mode === \"list\") {\n            return this.findBestMoveFromList(board);\n        }\n        return this.findRandomMove(board);\n    }\n\n    static findBestMinimaxMove(board) {\n        let possibleMoves = board.getBlankSquares();\n        let bestMoves = [];\n        let bestMoveEval = -2;\n        for (let moveIndex = 0; moveIndex < possibleMoves.length; moveIndex++) {\n            let move = possibleMoves[moveIndex]\n            let boardWithNewMove = board.copyWithMove(symbols[\"computer\"], move.row, move.cell);\n            let minimaxEval = this.evalMoveMinimax(boardWithNewMove, -1);\n            if (minimaxEval > bestMoveEval) {\n                bestMoveEval = minimaxEval;\n                bestMoves = [move];\n            } else if (minimaxEval == bestMoveEval) {\n                bestMoves.push(move);\n            }\n        }\n        if (bestMoveEval == -2) {\n            console.log(\"Something bad happened!\");\n            return null;\n        }\n        let bestMove = Utils.randomElementFromArray(bestMoves);\n        return bestMove;\n    }\n\n    static evalMoveMinimax(board, turn) {\n        let possibleMoves = board.getBlankSquares();\n        // Check for terminal states\n        let gameState = board.getGameState();\n        if (gameState !== symbols[\"blank\"]) {\n            return gameState == symbols[\"computer\"] ? 1 : -1;\n        }\n        if (possibleMoves.length < 1) {\n            return 0;\n        }\n        let bestMoveEval = 0;\n        if (turn == -1) {\n            // MINI\n            bestMoveEval = 2;\n            for (let i = 0; i < possibleMoves.length; i++) {\n                let move = possibleMoves[i];\n                let boardWithNewMove = board.copyWithMove(symbols[\"player\"], move.row, move.cell);\n                let currentMoveEval = this.evalMoveMinimax(boardWithNewMove, -turn);\n                if (currentMoveEval < bestMoveEval) {\n                    bestMoveEval = currentMoveEval;\n                }\n            }\n        } else {\n            // MAX\n            bestMoveEval = -2;\n            for (let i = 0; i < possibleMoves.length; i++) {\n                let move = possibleMoves[i];\n                let boardWithNewMove = board.copyWithMove(symbols[\"computer\"], move.row, move.cell);\n                let currentMoveEval = this.evalMoveMinimax(boardWithNewMove, -turn);\n                if (currentMoveEval > bestMoveEval) {\n                    bestMoveEval = currentMoveEval;\n                }\n            }\n        }\n        return bestMoveEval;\n    }\n\n    static findBestMoveFromList(board) {\n        let favouredMoves = [\n            {row: 1, cell: 1},\n            {row: 0, cell: 1},\n            {row: 1, cell: 2},\n            {row: 2, cell: 1},\n            {row: 1, cell: 0},\n            {row: 0, cell: 0},\n            {row: 0, cell: 2},\n            {row: 2, cell: 2},\n            {row: 2, cell: 0},\n        ];\n        for (let moveIndex = 0; moveIndex < favouredMoves.length; moveIndex++) {\n            const currentMove = favouredMoves[moveIndex];\n            if (board.getSquare(currentMove.row, currentMove.cell) == symbols[\"blank\"]) {\n                return currentMove;\n            }\n        }\n        return null;\n    }\n    \n    static findRandomMove(board) {\n        let blankSquares = board.getBlankSquares();\n        return Utils.randomElementFromArray(blankSquares);\n    }\n}"]}