{"version":3,"sources":["../../src/js/AI.js"],"names":["AI","board","mode","findBestMoveFromList","findRandomMove","findLimitedMinimaxMove","findBestMinimaxMove","possibleMoves","getBlankSquares","bestMoves","bestMoveEval","moveIndex","length","move","boardWithNewMove","copyWithMove","symbols","row","cell","minimaxEval","evalMoveLimitedMinimax","push","console","log","bestMove","Utils","randomElementFromArray","turn","depth","MAX_DEPTH","gameState","getGameState","i","currentMoveEval","evalMoveMinimax","favouredMoves","currentMove","getSquare","blankSquares"],"mappings":"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","file":"AI.js","sourcesContent":["class AI {\n    static findBestMove(board, mode) {\n        if (mode === \"easy\") {\n            return this.findBestMoveFromList(board);\n        } else if (mode === \"medium\") {\n            return this.findRandomMove(board);\n        } else if (mode === \"hard\") {\n            return this.findLimitedMinimaxMove(board);\n        } else { \n            return this.findBestMinimaxMove(board);\n        }\n    }\n\n    static findLimitedMinimaxMove(board) {\n        let possibleMoves = board.getBlankSquares();\n        let bestMoves = [];\n        let bestMoveEval = -2;\n        for (let moveIndex = 0; moveIndex < possibleMoves.length; moveIndex++) {\n            let move = possibleMoves[moveIndex]\n            let boardWithNewMove = board.copyWithMove(symbols[\"computer\"], move.row, move.cell);\n            let minimaxEval = this.evalMoveLimitedMinimax(boardWithNewMove, -1, 0);\n            if (minimaxEval > bestMoveEval) {\n                bestMoveEval = minimaxEval;\n                bestMoves = [move];\n            } else if (minimaxEval == bestMoveEval) {\n                bestMoves.push(move);\n            }\n        }\n        if (bestMoveEval == -2) {\n            console.log(\"Something bad happened!\");\n            return null;\n        }\n        let bestMove = Utils.randomElementFromArray(bestMoves);\n        return bestMove;\n    }\n\n    static evalMoveLimitedMinimax(board, turn, depth) {\n        const MAX_DEPTH = 5; // 1 \"Depth\" is a move one way, 2 \"depths\" is one move from each side\n        if (depth >= MAX_DEPTH) {\n            return turn;\n        }\n        let possibleMoves = board.getBlankSquares();\n        // Check for terminal states\n        let gameState = board.getGameState();\n        if (gameState !== symbols[\"blank\"]) {\n            return gameState == symbols[\"computer\"] ? 1 : -1;\n        }\n        if (possibleMoves.length < 1) {\n            return 0;\n        }\n        let bestMoveEval = 0;\n        if (turn == -1) {\n            // MINI\n            bestMoveEval = 2;\n            for (let i = 0; i < possibleMoves.length; i++) {\n                let move = possibleMoves[i];\n                let boardWithNewMove = board.copyWithMove(symbols[\"player\"], move.row, move.cell);\n                let currentMoveEval = this.evalMoveLimitedMinimax(boardWithNewMove, -turn, depth+1);\n                if (currentMoveEval < bestMoveEval) {\n                    bestMoveEval = currentMoveEval;\n                }\n            }\n        } else {\n            // MAX\n            bestMoveEval = -2;\n            for (let i = 0; i < possibleMoves.length; i++) {\n                let move = possibleMoves[i];\n                let boardWithNewMove = board.copyWithMove(symbols[\"computer\"], move.row, move.cell);\n                let currentMoveEval = this.evalMoveLimitedMinimax(boardWithNewMove, -turn, depth+1);\n                if (currentMoveEval > bestMoveEval) {\n                    bestMoveEval = currentMoveEval;\n                }\n            }\n        }\n        return bestMoveEval;\n    }\n\n    static findBestMinimaxMove(board) {\n        let possibleMoves = board.getBlankSquares();\n        let bestMoves = [];\n        let bestMoveEval = -2;\n        for (let moveIndex = 0; moveIndex < possibleMoves.length; moveIndex++) {\n            let move = possibleMoves[moveIndex]\n            let boardWithNewMove = board.copyWithMove(symbols[\"computer\"], move.row, move.cell);\n            let minimaxEval = this.evalMoveMinimax(boardWithNewMove, -1);\n            if (minimaxEval > bestMoveEval) {\n                bestMoveEval = minimaxEval;\n                bestMoves = [move];\n            } else if (minimaxEval == bestMoveEval) {\n                bestMoves.push(move);\n            }\n        }\n        if (bestMoveEval == -2) {\n            console.log(\"Something bad happened!\");\n            return null;\n        }\n        let bestMove = Utils.randomElementFromArray(bestMoves);\n        return bestMove;\n    }\n\n    static evalMoveMinimax(board, turn) {\n        let possibleMoves = board.getBlankSquares();\n        // Check for terminal states\n        let gameState = board.getGameState();\n        if (gameState !== symbols[\"blank\"]) {\n            return gameState == symbols[\"computer\"] ? 1 : -1;\n        }\n        if (possibleMoves.length < 1) {\n            return 0;\n        }\n        let bestMoveEval = 0;\n        if (turn == -1) {\n            // MINI\n            bestMoveEval = 2;\n            for (let i = 0; i < possibleMoves.length; i++) {\n                let move = possibleMoves[i];\n                let boardWithNewMove = board.copyWithMove(symbols[\"player\"], move.row, move.cell);\n                let currentMoveEval = this.evalMoveMinimax(boardWithNewMove, -turn);\n                if (currentMoveEval < bestMoveEval) {\n                    bestMoveEval = currentMoveEval;\n                }\n            }\n        } else {\n            // MAX\n            bestMoveEval = -2;\n            for (let i = 0; i < possibleMoves.length; i++) {\n                let move = possibleMoves[i];\n                let boardWithNewMove = board.copyWithMove(symbols[\"computer\"], move.row, move.cell);\n                let currentMoveEval = this.evalMoveMinimax(boardWithNewMove, -turn);\n                if (currentMoveEval > bestMoveEval) {\n                    bestMoveEval = currentMoveEval;\n                }\n            }\n        }\n        return bestMoveEval;\n    }\n\n    static findBestMoveFromList(board) {\n        let favouredMoves = [\n            {row: 1, cell: 1},\n            {row: 0, cell: 1},\n            {row: 1, cell: 2},\n            {row: 2, cell: 1},\n            {row: 1, cell: 0},\n            {row: 0, cell: 0},\n            {row: 0, cell: 2},\n            {row: 2, cell: 2},\n            {row: 2, cell: 0},\n        ];\n        for (let moveIndex = 0; moveIndex < favouredMoves.length; moveIndex++) {\n            const currentMove = favouredMoves[moveIndex];\n            if (board.getSquare(currentMove.row, currentMove.cell) == symbols[\"blank\"]) {\n                return currentMove;\n            }\n        }\n        return null;\n    }\n    \n    static findRandomMove(board) {\n        let blankSquares = board.getBlankSquares();\n        return Utils.randomElementFromArray(blankSquares);\n    }\n}"]}