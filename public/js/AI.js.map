{"version":3,"sources":["../../src/js/AI.js"],"names":["AI","board","mode","findBestMoveFromList","findRandomMove","findBestMoveBadAI","findBestMinimaxMove","possibleMoves","getBlankSquares","getGameState","symbols","length","console","log","winningMoves","nonLosingMoves","losingMoves","moveLoop","move","boardWithNewMove","copyWithMove","row","cell","gameState","push","possiblePlayerResponses","playerResponse","boardWithPlayerResponse","gameStateWithPlayerMove","Utils","randomElementFromArray","bestMoves","bestMoveEval","moveIndex","minimaxEval","evalMoveMinimax","bestMove","turn","i","currentMoveEval","favouredMoves","currentMove","getSquare","blankSquares"],"mappings":"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","file":"AI.js","sourcesContent":["class AI {\n    static findBestMove(board, mode) {\n        if (mode === \"easy\") {\n            return this.findBestMoveFromList(board);\n        } else if (mode === \"medium\") {\n            return this.findRandomMove(board);\n        } else if (mode === \"hard\") {\n            return this.findBestMoveBadAI(board);\n        } else {\n            return this.findBestMinimaxMove(board);\n        }\n    }\n\n    static findBestMoveBadAI(board) {\n        let possibleMoves = board.getBlankSquares();\n        if (board.getGameState() !== symbols['blank'] || possibleMoves.length == 0) {\n            return null;\n        }\n        console.log(`board: ${board}`);\n        let winningMoves = [];\n        let nonLosingMoves = [];\n        let losingMoves = [];\n        moveLoop:\n        for (const move of possibleMoves) {\n            let boardWithNewMove = board.copyWithMove(symbols['computer'], move.row, move.cell);\n            let gameState = boardWithNewMove.getGameState();\n            if (gameState === symbols['computer']) {\n                winningMoves.push(move);\n                continue;\n            }\n            let possiblePlayerResponses = boardWithNewMove.getBlankSquares();\n            for (const playerResponse of possiblePlayerResponses) {\n                let boardWithPlayerResponse = boardWithNewMove.copyWithMove(symbols['player'], playerResponse.row, playerResponse.cell);\n                let gameStateWithPlayerMove = boardWithPlayerResponse.getGameState();\n                if (gameStateWithPlayerMove === symbols['player']) {\n                    losingMoves.push(move);\n                    continue moveLoop;\n                }\n            }\n            nonLosingMoves.push(move);\n        }\n        console.log({ winningMoves, nonLosingMoves, losingMoves });\n        if (winningMoves.length > 0) {\n            return Utils.randomElementFromArray(winningMoves);\n        } else if (nonLosingMoves.length > 0) {\n            return Utils.randomElementFromArray(nonLosingMoves);\n        } else if (losingMoves.length > 0) {\n            return Utils.randomElementFromArray(losingMoves);\n        }\n        // No moves\n        return null\n    }\n\n    static findBestMinimaxMove(board) {\n        let possibleMoves = board.getBlankSquares();\n        let bestMoves = [];\n        let bestMoveEval = -2;\n        for (let moveIndex = 0; moveIndex < possibleMoves.length; moveIndex++) {\n            let move = possibleMoves[moveIndex]\n            let boardWithNewMove = board.copyWithMove(symbols[\"computer\"], move.row, move.cell);\n            let minimaxEval = this.evalMoveMinimax(boardWithNewMove, -1);\n            if (minimaxEval > bestMoveEval) {\n                bestMoveEval = minimaxEval;\n                bestMoves = [move];\n            } else if (minimaxEval == bestMoveEval) {\n                bestMoves.push(move);\n            }\n        }\n        if (bestMoveEval == -2) {\n            console.log(\"Something bad happened!\");\n            return null;\n        }\n        let bestMove = Utils.randomElementFromArray(bestMoves);\n        return bestMove;\n    }\n\n    static evalMoveMinimax(board, turn) {\n        let possibleMoves = board.getBlankSquares();\n        // Check for terminal states\n        let gameState = board.getGameState();\n        if (gameState !== symbols[\"blank\"]) {\n            return gameState == symbols[\"computer\"] ? 1 : -1;\n        }\n        if (possibleMoves.length < 1) {\n            return 0;\n        }\n        let bestMoveEval = 0;\n        if (turn == -1) {\n            // MINI\n            bestMoveEval = 2;\n            for (let i = 0; i < possibleMoves.length; i++) {\n                let move = possibleMoves[i];\n                let boardWithNewMove = board.copyWithMove(symbols[\"player\"], move.row, move.cell);\n                let currentMoveEval = this.evalMoveMinimax(boardWithNewMove, -turn);\n                if (currentMoveEval < bestMoveEval) {\n                    bestMoveEval = currentMoveEval;\n                }\n            }\n        } else {\n            // MAX\n            bestMoveEval = -2;\n            for (let i = 0; i < possibleMoves.length; i++) {\n                let move = possibleMoves[i];\n                let boardWithNewMove = board.copyWithMove(symbols[\"computer\"], move.row, move.cell);\n                let currentMoveEval = this.evalMoveMinimax(boardWithNewMove, -turn);\n                if (currentMoveEval > bestMoveEval) {\n                    bestMoveEval = currentMoveEval;\n                }\n            }\n        }\n        return bestMoveEval;\n    }\n\n    static findBestMoveFromList(board) {\n        let favouredMoves = [{\n                row: 1,\n                cell: 1\n            },\n            {\n                row: 0,\n                cell: 1\n            },\n            {\n                row: 1,\n                cell: 2\n            },\n            {\n                row: 2,\n                cell: 1\n            },\n            {\n                row: 1,\n                cell: 0\n            },\n            {\n                row: 0,\n                cell: 0\n            },\n            {\n                row: 0,\n                cell: 2\n            },\n            {\n                row: 2,\n                cell: 2\n            },\n            {\n                row: 2,\n                cell: 0\n            },\n        ];\n        for (let moveIndex = 0; moveIndex < favouredMoves.length; moveIndex++) {\n            const currentMove = favouredMoves[moveIndex];\n            if (board.getSquare(currentMove.row, currentMove.cell) == symbols[\"blank\"]) {\n                return currentMove;\n            }\n        }\n        return null;\n    }\n\n    static findRandomMove(board) {\n        let blankSquares = board.getBlankSquares();\n        return Utils.randomElementFromArray(blankSquares);\n    }\n}"]}